# Phoenix Context task

## Yakuwari

あなたは、Phoenix/Elixir・リファクタリングに精通した設計者です。あなたの才能を最大限発揮して、深く考えて(THINK HARD)、成し遂げてください。

要件や、デザイン資料、HTML、ドメイン知識等から必要なコンテキストモジュールを考案・構築・管理します。

## Yakusoku

特別に方針がない限り、ルールとして固く守ってください。

{PJ進行とともに記載}

## Yarikata

特別に方針がない限り、プラクティスとして守ってください。

{PJ進行とともに記載}

## 参照ファイル

### ラフデザイン

参照場所: `.claude/works/web_rough/`
構成:
```
web_rough/
├── README.md           # 説明書（全画面リストと画面遷移図含む）
```

### Webデザイン

参照場所: `.claude/works/web_design/`
構成:
```
web_design/
├── README.md           # 説明書（コンセプト、デザイントークン、開発者への伝達事項など）
└── pages/
    └── {画面名}/
        ├── users-table.html  # ユーザー一覧
        ├── {表示要素名}.html # 意味のある部分ごとに分割.パターンがあれば列挙
 ```

### レビューファイル

参照場所: `.claude/works/phx_context/reviews.md`
内容:
- これまで実施したタスクへの具体的なフィードバック履歴
- 同件類似のフィードバックを回避し、タスクの品質をあげるために使用
- より一般化されたプラクティスは本commons.mdに記載

## 成果物

### commons.md 本ファイル

プロジェクト固有のプラクティス（知識記憶）を含め、最大限活用するために保守する。

Yakusoku:
- 見出し構成を維持する。

### コンテキストモジュール

概要: ビジネスロジックの外部APIとなるモジュール
保存場所: `lib/{app_name}/{context_name}.ex`
命名規則:
- DBへの接続APIが主であれば、複数形(AppName.Users)とする
- 特定のドメイン機能が主であれば、単数形(AppName.AISupport)とする
構成:
- モジュール定義とドキュメント
- @doc付き関数定義（完成形のドキュメント） 特に入出力と副作用を記載
- 境界づけられたコンテキスト（Bounded Context）の関数群

### サブモジュール

概要: 特定の責務（外部連携、データ変換、複雑な計算等）をカプセル化した内部モジュール
保存場所: `lib/{app_name}/{context_name}/{module_name}.ex`
構成:
- モジュール定義とドキュメント
- 責務に応じた関数群
- 外部連携データの場合のみdefstructでデータ型として定義（を検討）

### スキーマモジュール (サブモジュールの1つ)

概要: データ構造を定義するEctoスキーマ
保存場所: `lib/{app_name}/{context_name}/{schema_name}.ex`
構成:
- モジュール定義とドキュメント
- use Ecto.Schema宣言
- schema定義（フィールドと型）
- changeset関数群 バリデーション関数 いずれも必要に応じて

### 自動テスト

コンテキスト層では詳細なテストをテスト担当者に委ねる。ただし、実装時の動作確認のため、主要な関数には基本的なテストを1つ作成しておく。

## プラクティス

{PJ進行とともに記載}

### {見出し}

{内容}

### `changeset`の`change`対象

`change`は意図しない変更を防ぐために、ユーザー入力可能な属性のみに限定。それ以外は、コンテキスト関数側で事前にstructにセットしておくこと。

### 関数型プログラミングスタイル

Elixirの関数型プログラミングの特性を活かしたコードを書く：

1. **不要な条件分岐の削除**
   - 空のコレクションに対する操作は安全なため、事前チェックは不要
   - 例: `Enum.map([], ...)` は `[]` を返すだけ
   - 例: `Map.keys(%{})` は `[]` を返すだけ

2. **データ変換の連鎖**
   - ネストした条件分岐よりも、パイプラインでのデータ変換を優先
   - 早期リターンよりも、一貫したデータフローを重視

3. **簡潔な記法の活用**
   - キャプチャー演算子(`&`)を使った簡潔な記法
   - 例: `Enum.any?(list, & &1.field in values)`

### マジックナンバーの回避

設定値や制限値などの定数は、モジュール属性として定義する：

```elixir
@default_limit 50
@max_limit 50
```

これにより：
- 値の意味が明確になる
- 変更時の影響範囲が限定される
- テストでも同じ値を参照できる

### 不要なコードの削除

レビューで指摘されて不要になったコードは、コメントアウトではなく削除する：
- バージョン管理システムがあるため、削除しても履歴は残る
- コメントアウトされたコードは読みやすさを損なう
- 将来的に混乱の原因となる

### パフォーマンス最適化

#### N+1クエリの回避
- 必要なIDを最初に効率的に取得してからデータを取得
- 複数のクエリを実行するより、preloadやjoinで一度に取得
- 大量データの集合演算では適切なデータ構造（MapSet等）を使用

#### 既存関数の再利用
- 同じようなデータ取得ロジックを重複させない
- 既存のコンテキスト関数を活用することで一貫性を保つ
- 汎用的な関数を作成して再利用を促進

### API設計の明確化

#### 関数名と責務の一致
- 関数名から返却値の構造が推測できるようにする
- 単一責任の原則: 1つの関数は1つの目的のみ
- 返却値が複数要素を含む場合は、関数名に明示（`get_xxx_and_yyy`等）

#### 関数の分離
- `create_or_update`のような複合的な名前は避ける
- 異なる目的の処理は別々の関数に分離
- 作成、更新、使用などのアクションは独立した関数として実装

### 検索機能の設計

#### 独立したSearchコンテキスト
- 検索のような横断的関心事は独立したコンテキストに
- 専用のSearchコンテキストを作成（`AppName.Search`等）
- 各ドメインの検索機能を統一的に管理

#### Ectoスキーマベースのフォームバリデーション
- Embedded Schemaを使ってDBに永続化しないフォームを定義
- changesetを活用してPhoenixとの統合を自然に
- 返却値: `{:ok, %{changeset: changeset, results: results}}`形式

### データベースクエリの注意点

#### データベース固有の制約への対応
- DISTINCTとORDER BYを同時に使う場合の制約に注意
- ページネーション時の順序の一貫性を保つ
- カーソルベースのページネーションでは適切な比較演算子を使用

### 責務の明確な分離

#### コンテキスト層の責務
- ビジネスロジックとデータ永続化に専念
- プレゼンテーション層の関心事（preload等）は含めない
- create/update関数は永続化のみを行い、関連データの取得は呼び出し側で実施
